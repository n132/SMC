#n132
def AND(a,b):
    return a and b
def OR(a,b):
    return a or b
def XOR(a,b):
    return a^b
def NOT(a):
    assert(a<=1 and a>=0)
    return 1-a
SWICT = {
    "AND":AND,"and":AND,
    "OR":OR,"or":OR,
    "XOR":XOR,"xor":XOR,
}
import json
from utils import *
class GarbledGates(object):
    def __init__(self,wire_a,wire_b,logic,gid=0) -> None:
        super().__init__()
        if(logic==b"AND" or logic == b"and"):
            self.gate = AND
        elif(logic==b"OR" or logic == b"or"):
            self.gate = OR
        elif(logic==b"XOR" or logic == b"xor"):
            self.gate = XOR
        else:
            exit(1)
        self.a =wire_a
        self.b =wire_b
        self.k =None
        self.c =None
        self.keys = [[0,0],[0,0],[0,0]]
        self.GetKeys()
        self.gid = gid

    def GetKeys(self):
        for x in range(3):
            for y in range(2):
                self.keys[x][y] = kengen()
        return self.keys
    def encCircuit(self):
        #Generate encrypted data with generated keys
        #-----------------------------------
        
        self.k = [[0,0],[0,0],[0,0]]
        for x in range(3):
            for y in range(2):
                self.k[x][y] = encrypt(self.keys[x][y],str(y).encode())
        #Generate garbled output
        #-----------------------------------
        ptr = self.keys
        self.c=[]
        for x in range(2):
            tmp = []
            for y in range(2):
                content  = self.k[2][self.gate(x,y)]
                tmp.append( encrypt(ptr[0][x],encrypt(ptr[1][y],content)) )
            self.c+= tmp
        return 
        #pack the data
        #-----------------------------------
        # for x in self.c:
        #     print(x)
        # for y in self.keys:
        #     print(y)
        #---------------------------------------------
    def pack(self):
        key = [] 
        for _ in self.keys:
            key += [__.decode() for __ in _]
        tmp = []

        for _ in self.c:
            tmp.append( _.decode() )
        data = {
            "GID": self.gid,#Gate ID
            "KEYS": key,
            "OUT": tmp
        }
        res = json.dumps(data)
        return res
    def unpack(self,data):
        data = json.loads(data)
        return data
        #print(data['KEYS'])

    def genGC(self):
        self.encCircuit()
        return self.pack()
# based on Lecture 10 page 14    
    
    
def cGarble(info,labels):
    # input: info-> a circuit c, ;labels-> iLables generated by fucntion iLable
    # output: gc, a garbled circuit
    # by using GarbledGates, we could generate the needed info for each gate
    gates       = info["gates"]
    gc = []

    for _ in gates:
        gate = {}
        res = []
        logic =SWICT[_['type']]
        for x in range(2):
            for y in range(2):
                # get output lables
                gate_out =  logic(x,y)
                assert(gate_out==0 or gate_out==1)
                raw_label = labels[_['output'][0]*2+gate_out]
                # get keys from labels
                key1 = labels[_['input'][0]*2+x]
                key2 = labels[_['input'][1]*2+y]
                # encrypt the out_lable
                tmp = encrypt(
                    key2,encrypt(key1,raw_label)
                    )
                res.append(tmp)
        # we except to have 4 or 1 encrypted output for each gate
        gate['id'] = _['id']
        gate['garbledResult'] = res 
        gc.append(gate)
    # gc process finished.
    return gc
    
def gcEval():
    pass
def iLabel(info):
    # Random string could use keygen to generate
    # input : a circuit C
    # output : generate inpute Labels
    # total num =input wires + number of gates
    # so it's a problem to dirscribe a circuit with
    gates       = info["gates"]
    inputs      = info["inputs"]
    total_num   = len(gates) + len(inputs)
    res = []
    for _ in range(total_num*2):
        res.append(kengen())
    # real index = from (id*2)  to (id*2+1)
    return res

def tester():
    with open("./equal.json") as f:
        data = f.read()
    info = json.loads(data)
    res = iLabel(info)
    #print((res))
    cGarble(info,res)


if __name__ == "__main__":
    a= GarbledGates(1,0,b"AND")
    a.encCircuit()
    c= a.pack()
    res = a.unpack(c)
    wire=[]
    tester()
    #wire.append(res['KYES'][:2])
    #wire.append(res['KYES'][2:4])
    #output = res['KYES'][4:]

    