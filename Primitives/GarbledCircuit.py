#n132
def AND(a,b):
    return a and b
def OR(a,b):
    return a or b
def XOR(a,b):
    return a^b
def NOT(a):
    assert(a<=1 and a>=0)
    return 1-a
SWICT = {
    "AND":AND,"and":AND,
    "OR":OR,"or":OR,
    "XOR":XOR,"xor":XOR,
}
import json
from operator import indexOf

from sympy.polys.densetools import _rec_integrate_in
from utils import *
class GarbledGates(object):
    def __init__(self,wire_a,wire_b,logic,gid=0) -> None:
        super().__init__()
        if(logic==b"AND" or logic == b"and"):
            self.gate = AND
        elif(logic==b"OR" or logic == b"or"):
            self.gate = OR
        elif(logic==b"XOR" or logic == b"xor"):
            self.gate = XOR
        else:
            exit(1)
        self.a =wire_a
        self.b =wire_b
        self.k =None
        self.c =None
        self.keys = [[0,0],[0,0],[0,0]]
        self.GetKeys()
        self.gid = gid

    def GetKeys(self):
        for x in range(3):
            for y in range(2):
                self.keys[x][y] = kengen()
        return self.keys
    def encCircuit(self):
        #Generate encrypted data with generated keys
        #-----------------------------------
        
        self.k = [[0,0],[0,0],[0,0]]
        for x in range(3):
            for y in range(2):
                self.k[x][y] = encrypt(self.keys[x][y],str(y).encode())
        #Generate garbled output
        #-----------------------------------
        ptr = self.keys
        self.c=[]
        for x in range(2):
            tmp = []
            for y in range(2):
                content  = self.k[2][self.gate(x,y)]
                tmp.append( encrypt(ptr[0][x],encrypt(ptr[1][y],content)) )
            self.c+= tmp
        return 
        #pack the data
        #-----------------------------------
        # for x in self.c:
        #     print(x)
        # for y in self.keys:
        #     print(y)
        #---------------------------------------------
    def pack(self):
        key = [] 
        for _ in self.keys:
            key += [__.decode() for __ in _]
        tmp = []

        for _ in self.c:
            tmp.append( _.decode() )
        data = {
            "GID": self.gid,#Gate ID
            "KEYS": key,
            "OUT": tmp
        }
        res = json.dumps(data)
        return res
    def unpack(self,data):
        data = json.loads(data)
        return data
        #print(data['KEYS'])

    def genGC(self):
        self.encCircuit()
        return self.pack()
# based on Lecture 10 page 14    
    
def iLabel(info):
    # Random string could use keygen to generate
    # input : a circuit C
    # output : generate inpute Labels
    # total num =input wires + number of gates
    # so it's a problem to dirscribe a circuit with
    gates       = info["gates"]
    inputs      = info["inputs"]
    total_num   = len(gates) + len(inputs)
    res = []
    for _ in range(total_num*2):
        res.append(kengen())
    # real index = from (id*2)  to (id*2+1)
    return res 
def cGarble(info,labels):
    # input: info-> a circuit c, ;labels-> iLables generated by fucntion iLable
    # output: gc, a garbled circuit
    # by using GarbledGates, we could generate the needed info for each gate
    #    --------------
    # info must be well designed and the dependance problem is solved
    gates       = info["gates"]
    gc = []
    for _ in gates:
        gate = {}
        res = []
        logic =SWICT[_['type']]
        for x in range(2):
            for y in range(2):
                # get output lables
                gate_out =  logic(x,y)
                assert(gate_out==0 or gate_out==1)
                raw_label = labels[_['output'][0]*2+gate_out]
                # get keys from labels
                key1 = labels[_['input'][0]*2+x]
                key2 = labels[_['input'][1]*2+y]
                # encrypt the out_lable
                tmp = encrypt(
                    key2,encrypt(key1,raw_label)
                    )
                res.append(tmp)
        # we except to have 4 or 1 encrypted output for each gate
        gate['id'] = _['id']
        gate['garbledResult'] = res 
        gc.append(gate)
    # gc process finished.
    # We need to give the receiver the final output's map so he could know the result.
    result_map = [
        labels[info['output'][0]*2+0],
        labels[info['output'][0]*2+1]
    ]
    
    return gc,result_map
    #about the input/output information:not sure now
    #if needed, add later
def gateCalculator(w1,w2,table):
    for _ in table:
        try:
            res=decrypt(
                w1,decrypt(w2,_)
            )
            if(res):
                return res
        except Exception:
            pass
    print("Fatal Exit")
    exit(1)
def gcEval(gc,inputs,info,result_map):
    # input: gc, ilabels
    # output: circuit result bit b
    #    assert(len(input_lables)==gc[int])
    '''
        info
        {'id': 0, 'type': 'XOR', 'input': [0, 2], 'output': [4]}
        {'id': 1, 'type': 'XOR', 'input': [1, 3], 'output': [5]}
        {'id': 2, 'type': 'or', 'input': [4, 5], 'output': [6]} 
    '''
    assert(len(inputs) == len(info['inputs']))
    inputs+=[0]*(info['output'][0]+1-len(inputs))
    for x in gc:
        '''
        example:
        {'id': 0, 'garbledResult': [b'gAAAAABhroreq5oIlH1xpSbMh3WRC0kO30A8OaJ8dMoTLaJAtLogy8MjLW0FMelBn6AAW39XvxShbr7wK1LTbWyd1wBAL1YZTN8LBj3mVkbvhshiu1Ye9-yjuf2YuvQT3ErqQkKFD92MxKUc4u_g30O0Gkq_7q_J_ah5aHOMOBSxstwU8u0xRLN_7K4XdLJecey0m9votJiJASTtrHF5iRY2thsDIABaURsxShDS1FDptHG6S6nlkprwRY7Nx3-FaZTaqG-BR6jX', b'gAAAAABhroreg94DG2-9xqd43A52imUOBgcGJgnmo0Q3PrdtzF3kSN5DikPL44bEtifvvAdInW8V_D8X_Av22Ux7p4y57hS39Z0gICencC_jdAoYwfPb3fiXxwH5JtbpWfm0tkmKC0dfGcxyvEhHEqp_lcZWq-MUju7Nh40nJXEfiX307kdGG1pual6gjNtPJqUNX2o48kJRCMFy8GIaSWJDNE8QzSPCm77I6QZrv5umV1qR0ffiQDF7dzrL1bSJ3licagyaVl3L', b'gAAAAABhroreBxGPQz85d5Z-9Bo4r7vMcGhN0yZU6KSSdqig4jK66k2pXcscD71BDP4qIKjwwQV7WSP2S4ermVw8E6__IeMDAtU0lE2v0zEB-bSDKUq7Wr8RDnWtH_qxwjoQx3AcsG8HMt6b2PruVHDgftwcWg1W7R5BI17W6P6LiwrSZz_6FE07sD60fPNq2F9yVXJjtWdwK5cy1Eb7MFzz4k3VZvtnyfvfBWWgORi6IDYh6RZx-ajLrDsenJ0xgQK9f5DHTwJp', b'gAAAAABhrore7tYObbAaA9D3SmbD8nSvawzo3CZA3NyVU4YJjY0xYusawiwzidm5lzkU4wsuel5R6SSkj3lHHb2iUdww8PP8Y7HW4EUvalN_G0FECRnPXSoKhEJ9R9qeWzlzosKppUiHmYlYTLisFYd0dmsk-g5KZvTmv3RWm20QeF8xIIaGV6qvbKbQ9-BxM7hgU7NkBujG_Nn0en8vF1bzZjTRjNFo_6DbZZa_53r-ZLNEuYW4wTpHeZXU1ZvjTrdE7QitTwKs']}
        '''
        wire1 = inputs[info['gates'][x['id']]['input'][0]]
        wire2 = inputs[info['gates'][x['id']]['input'][1]]
        output_idx= info['gates'][x['id']]['output'][0]
        res = gateCalculator(wire1,wire2,x['garbledResult'])
        inputs[output_idx] = res
    return result_map.index(inputs[info['output'][0]])

def tester():
    with open("./equal.json") as f:
        data = f.read()
    info = json.loads(data)
    res = iLabel(info)
    #print((res))
    gc ,result_map = cGarble(info,res)
    l=[]
    pt=[]
    for x in range(4):
        r = randint(0,1)
        pt.append(r)
        l.append(res[x*2+r])
    res= gcEval(gc,l,info,result_map)
    #print(res)
    real= (pt[0]^pt[2]) or ((pt[1]^pt[3]))
    try:
        assert(real==res)
        return 1
    except Exception:
        return 0
    #print(real)
    #print(pt)
#    assert(res==)

if __name__ == "__main__":
    ct =0 
    for x in range(1000):  
        ct +=tester()
    print(ct/1000)
    #wire.append(res['KYES'][:2])
    #wire.append(res['KYES'][2:4])
    #output = res['KYES'][4:]

    