#n132
def AND(a,b):
    return a and b
def OR(a,b):
    return a or b
def XOR(a,b):
    return a^b
def NOT(a):
    assert(a<=1 and a>=0)
    return 1-a
SWICT = {
    "AND":AND,"and":AND,
    "OR":OR,"or":OR,
    "XOR":XOR,"xor":XOR,
}
import json

from sympy.polys.densetools import _rec_integrate_in
from utils import *
class GarbledGates(object):
    def __init__(self,wire_a,wire_b,logic,gid=0) -> None:
        super().__init__()
        if(logic==b"AND" or logic == b"and"):
            self.gate = AND
        elif(logic==b"OR" or logic == b"or"):
            self.gate = OR
        elif(logic==b"XOR" or logic == b"xor"):
            self.gate = XOR
        else:
            exit(1)
        self.a =wire_a
        self.b =wire_b
        self.k =None
        self.c =None
        self.keys = [[0,0],[0,0],[0,0]]
        self.GetKeys()
        self.gid = gid

    def GetKeys(self):
        for x in range(3):
            for y in range(2):
                self.keys[x][y] = kengen()
        return self.keys
    def encCircuit(self):
        #Generate encrypted data with generated keys
        #-----------------------------------
        
        self.k = [[0,0],[0,0],[0,0]]
        for x in range(3):
            for y in range(2):
                self.k[x][y] = encrypt(self.keys[x][y],str(y).encode())
        #Generate garbled output
        #-----------------------------------
        ptr = self.keys
        self.c=[]
        for x in range(2):
            tmp = []
            for y in range(2):
                content  = self.k[2][self.gate(x,y)]
                tmp.append( encrypt(ptr[0][x],encrypt(ptr[1][y],content)) )
            self.c+= tmp
        return 
        #pack the data
        #-----------------------------------
        # for x in self.c:
        #     print(x)
        # for y in self.keys:
        #     print(y)
        #---------------------------------------------
    def pack(self):
        key = [] 
        for _ in self.keys:
            key += [__.decode() for __ in _]
        tmp = []

        for _ in self.c:
            tmp.append( _.decode() )
        data = {
            "GID": self.gid,#Gate ID
            "KEYS": key,
            "OUT": tmp
        }
        res = json.dumps(data)
        return res
    def unpack(self,data):
        data = json.loads(data)
        return data
        #print(data['KEYS'])

    def genGC(self):
        self.encCircuit()
        return self.pack()
# based on Lecture 10 page 14    
    
def iLabel(info):
    # Random string could use keygen to generate
    # input : a circuit C
    # output : generate inpute Labels
    # total num =input wires + number of gates
    # so it's a problem to dirscribe a circuit with
    gates       = info["gates"]
    inputs      = info["inputs"]
    total_num   = len(gates) + len(inputs)
    res = []
    for _ in range(total_num*2):
        res.append(kengen())
    # real index = from (id*2)  to (id*2+1)
    return res 
def cGarble(info,labels):
    # input: info-> a circuit c, ;labels-> iLables generated by fucntion iLable
    # output: gc, a garbled circuit
    # by using GarbledGates, we could generate the needed info for each gate
    #    --------------
    # info must be well designed and the dependance problem is solved
    gates       = info["gates"]
    gc = []
    for _ in gates:
        gate = {}
        res = []
        logic =SWICT[_['type']]
        for x in range(2):
            for y in range(2):
                # get output lables
                gate_out =  logic(x,y)
                assert(gate_out==0 or gate_out==1)
                raw_label = labels[_['output'][0]*2+gate_out]
                # get keys from labels
                key1 = labels[_['input'][0]*2+x]
                key2 = labels[_['input'][1]*2+y]
                # encrypt the out_lable
                tmp = encrypt(
                    key2,encrypt(key1,raw_label)
                    )
                res.append(tmp)
        # we except to have 4 or 1 encrypted output for each gate
        gate['id'] = _['id']
        gate['garbledResult'] = res 
        gc.append(gate)
    # gc process finished.
    # We need to give the receiver the final output's map so he could know the result.
    result_map = [
        labels[info['output'][0]*2+0],
        labels[info['output'][0]*2+1]
    ]
    
    return gc,result_map
    #about the input/output information:not sure now
    #if needed, add later
def gateCalculator(w1,w2,table):
    for _ in table:
        try:
            res=decrypt(
                w1,decrypt(w2,_)
            )
            if(res):
                return res
        except Exception:
            print(1)
    exit(1)
def gcEval(gc,inputs,info,result_map):
    # input: gc, ilabels
    # output: circuit result bit b
    #    assert(len(input_lables)==gc[int])
    assert(len(inputs) == len(info['inputs']))
    inputs+=[0]*(info['output'][0]+1-len(inputs))
    for x in gc:
        '''
        {'id': 0, 'type': 'XOR', 'input': [0, 2], 'output': [4]}
        {'id': 1, 'type': 'XOR', 'input': [1, 3], 'output': [5]}
        {'id': 2, 'type': 'or', 'input': [4, 5], 'output': [6]} 
        '''
        wire1 = inputs[info['gates'][x['id']]['input'][0]]
        wire2 = inputs[info['gates'][x['id']]['input'][1]]
        res = gateCalculator(wire1,wire2,x['garbledResult'])
        inputs[x['output'][0]] = res
    return inputs[info['output'][0]]




def tester():
    with open("./equal.json") as f:
        data = f.read()
    info = json.loads(data)
    res = iLabel(info)
    #print((res))
    gc ,result_map = cGarble(info,res)
    l=[]
    for x in range(4):
        l.append(res[x*2+randint(0,1)])
    gcEval(gc,l,info,result_map)
    

if __name__ == "__main__":
    a= GarbledGates(1,0,b"AND")
    a.encCircuit()
    c= a.pack()
    res = a.unpack(c)
    wire=[]
    tester()
    #wire.append(res['KYES'][:2])
    #wire.append(res['KYES'][2:4])
    #output = res['KYES'][4:]

    